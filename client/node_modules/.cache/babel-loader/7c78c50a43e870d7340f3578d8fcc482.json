{"ast":null,"code":"const setAttrs = (element, attributes) => {\n  if (typeof attributes === 'object') {\n    Object.keys(attributes).forEach(key => {\n      element.setAttribute(key, attributes[key]);\n    });\n  }\n};\nconst removeAttrs = function (element) {\n  for (var _len = arguments.length, attributes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    attributes[_key - 1] = arguments[_key];\n  }\n  attributes.forEach(attribute => {\n    element.removeAttribute(attribute);\n  });\n};\nconst createSVGElement = (element, container, attributes) => {\n  const el = document.createElementNS('http://www.w3.org/2000/svg', element);\n  if (typeof attributes === 'object') {\n    setAttrs(el, attributes);\n  }\n  if (typeof container !== 'undefined') {\n    container.appendChild(el);\n  }\n  return el;\n};\nconst generateLegendBackground = function (color) {\n  let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'horizontal';\n  if (typeof color === 'string') {\n    return `background-color: ${color}`;\n  }\n  if (color.length === 1) {\n    return `background-color: ${color[0]}`;\n  }\n  return `background-image: linear-gradient(${direction === 'horizontal' ? 'to right, ' : ''}${color.join(', ')})`;\n};\nconst defaultColors = ['#FF4589', '#FF5050', '#05DF9D', '#4FF2FD', '#2D9CDB', '#A0BBFF', '#FFD76F', '#F2C94C', '#FF9A9A', '#FFB178'];\nconst getDefaultColors = number => {\n  const colors = [...defaultColors];\n  const colorSet = [];\n  for (let i = 0; i < number; i++) {\n    // get a random color\n    const index = Math.abs(Math.round(Math.random() * (colors.length - 1)));\n    // push it to the list\n    colorSet.push(colors[index]);\n    // and remove it, so that it is not chosen again\n    colors.splice(index, 1);\n  }\n  return colorSet;\n};\n\n/*\n    Used in comparing existing values to value provided on update\n    It is limited to comparing arrays on purpose\n    Name is slightly unusual, in order not to be confused with Lodash method\n */\nconst areEqual = (value, newValue) => {\n  // If values are not of the same type\n  const type = Object.prototype.toString.call(value);\n  if (type !== Object.prototype.toString.call(newValue)) return false;\n  if (type !== '[object Array]') return false;\n  if (value.length !== newValue.length) return false;\n  for (let i = 0; i < value.length; i++) {\n    // if the it's a two dimensional array\n    const currentType = Object.prototype.toString.call(value[i]);\n    if (currentType !== Object.prototype.toString.call(newValue[i])) return false;\n    if (currentType === '[object Array]') {\n      // if row lengths are not equal then arrays are not equal\n      if (value[i].length !== newValue[i].length) return false;\n      // compare each element in the row\n      for (let j = 0; j < value[i].length; j++) {\n        if (value[i][j] !== newValue[i][j]) {\n          return false;\n        }\n      }\n    } else if (value[i] !== newValue[i]) {\n      // if it's a one dimensional array element\n      return false;\n    }\n  }\n  return true;\n};\nexport { generateLegendBackground, getDefaultColors, areEqual, createSVGElement, setAttrs, removeAttrs, defaultColors };","map":{"version":3,"names":["setAttrs","element","attributes","Object","keys","forEach","key","setAttribute","removeAttrs","attribute","removeAttribute","createSVGElement","container","el","document","createElementNS","appendChild","generateLegendBackground","color","direction","length","join","defaultColors","getDefaultColors","number","colors","colorSet","i","index","Math","abs","round","random","push","splice","areEqual","value","newValue","type","prototype","toString","call","currentType","j"],"sources":["D:/react-typescript-graphql-master/client/node_modules/funnel-graph-js/src/js/graph.js"],"sourcesContent":["const setAttrs = (element, attributes) => {\n    if (typeof attributes === 'object') {\n        Object.keys(attributes).forEach((key) => {\n            element.setAttribute(key, attributes[key]);\n        });\n    }\n};\n\nconst removeAttrs = (element, ...attributes) => {\n    attributes.forEach((attribute) => {\n        element.removeAttribute(attribute);\n    });\n};\n\nconst createSVGElement = (element, container, attributes) => {\n    const el = document.createElementNS('http://www.w3.org/2000/svg', element);\n\n    if (typeof attributes === 'object') {\n        setAttrs(el, attributes);\n    }\n\n    if (typeof container !== 'undefined') {\n        container.appendChild(el);\n    }\n\n    return el;\n};\n\nconst generateLegendBackground = (color, direction = 'horizontal') => {\n    if (typeof color === 'string') {\n        return `background-color: ${color}`;\n    }\n\n    if (color.length === 1) {\n        return `background-color: ${color[0]}`;\n    }\n\n    return `background-image: linear-gradient(${direction === 'horizontal'\n        ? 'to right, '\n        : ''}${color.join(', ')})`;\n};\n\nconst defaultColors = ['#FF4589', '#FF5050',\n    '#05DF9D', '#4FF2FD',\n    '#2D9CDB', '#A0BBFF',\n    '#FFD76F', '#F2C94C',\n    '#FF9A9A', '#FFB178'];\n\nconst getDefaultColors = (number) => {\n    const colors = [...defaultColors];\n    const colorSet = [];\n\n    for (let i = 0; i < number; i++) {\n        // get a random color\n        const index = Math.abs(Math.round(Math.random() * (colors.length - 1)));\n        // push it to the list\n        colorSet.push(colors[index]);\n        // and remove it, so that it is not chosen again\n        colors.splice(index, 1);\n    }\n    return colorSet;\n};\n\n/*\n    Used in comparing existing values to value provided on update\n    It is limited to comparing arrays on purpose\n    Name is slightly unusual, in order not to be confused with Lodash method\n */\nconst areEqual = (value, newValue) => {\n    // If values are not of the same type\n    const type = Object.prototype.toString.call(value);\n    if (type !== Object.prototype.toString.call(newValue)) return false;\n    if (type !== '[object Array]') return false;\n\n    if (value.length !== newValue.length) return false;\n\n    for (let i = 0; i < value.length; i++) {\n        // if the it's a two dimensional array\n        const currentType = Object.prototype.toString.call(value[i]);\n        if (currentType !== Object.prototype.toString.call(newValue[i])) return false;\n        if (currentType === '[object Array]') {\n            // if row lengths are not equal then arrays are not equal\n            if (value[i].length !== newValue[i].length) return false;\n            // compare each element in the row\n            for (let j = 0; j < value[i].length; j++) {\n                if (value[i][j] !== newValue[i][j]) {\n                    return false;\n                }\n            }\n        } else if (value[i] !== newValue[i]) {\n            // if it's a one dimensional array element\n            return false;\n        }\n    }\n\n    return true;\n};\n\nexport {\n    generateLegendBackground, getDefaultColors, areEqual, createSVGElement, setAttrs, removeAttrs, defaultColors\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}